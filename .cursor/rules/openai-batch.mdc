---
globs: "src/core/*,scripts/process_completed_batches.py,scripts/monitor_batches.py"
description: "OpenAI Batch API 처리 로직 구현 가이드"
---

# OpenAI Batch API 처리 로직

## 🤖 OpenAI Batch API 개요

### API 워크플로우
1. **배치 생성** → 입력 데이터 파일 업로드
2. **배치 실행** → 백그라운드에서 처리
3. **상태 모니터링** → 주기적으로 상태 확인
4. **결과 다운로드** → 완료 시 결과 파일 다운로드

### 배치 상태 관리
- `validating`: 입력 검증 중
- `in_progress`: 처리 진행 중
- `finalizing`: 처리 완료 중
- `completed`: 완료
- `failed`: 실패
- `expired`: 만료
- `cancelled`: 취소

## 📝 프롬프트 설계

### Clickbait 점수 측정 프롬프트
> **참고**: 실제 프롬프트 내용은 `keywords-config.mdc`의 **기본 Clickbait 판별 프롬프트** 섹션을 참조하세요.

**프롬프트 주요 특징:**
- 5단계 체계적 분석 과정
- 0-100 점수 구간별 평가 기준
- 출력 형식: `score : [정수]`, `reason : [설명]`
- 본문 내용 제한: 최대 700자

### 프롬프트 템플릿 관리
> **참고**: 프롬프트 버전 관리, A/B 테스트, 언론사별 특화 프롬프트 등은 `keywords-config.mdc`를 참조하세요.

**배치 처리에서의 프롬프트 사용법:**
- `src/config/prompts.py`에서 프롬프트 로드
- 배치 생성 시 프롬프트 버전 선택
- 프롬프트 템플릿에 `{title}`, `{content}` 변수 삽입

## 🔧 배치 처리 구현

### 입력 데이터 처리
```python
import re

def prepare_articles_for_batch(articles):
    """배치 처리를 위한 기사 데이터 준비"""
    processed_articles = []
    
    for article in articles:
        # 데이터 검증
        if not article.get('title') or not article.get('content'):
            continue
            
        # 내용 길이 제한 (700자)
        content = article['content'][:700]
        
        # HTML 태그 제거
        content = re.sub(r'<[^>]+>', '', content)
        
        # 중복 공백 제거
        content = re.sub(r'\s+', ' ', content).strip()
        
        processed_articles.append({
            'id': article['id'],
            'title': article['title'],
            'content': content
        })
    
    return processed_articles
```

### 배치 생성 로직
```python
def create_batch_request(articles, prompt_version="v1.1"):
    """배치 요청 생성"""
    from src.config.prompts import get_prompt_template
    
    prompt_template = get_prompt_template(prompt_version)
    batch_requests = []
    
    for article in articles:
        # 프롬프트에 기사 정보 삽입
        formatted_prompt = prompt_template.format(
            title=article['title'],
            content=article['content'][:700]  # 700자 제한
        )
        
        request = {
            "custom_id": f"article_{article['id']}",
            "method": "POST",
            "url": "/v1/chat/completions",
            "body": {
                "model": "gpt-4o-mini",
                "messages": [
                    {
                        "role": "system",
                        "content": "뉴스의 제목과 내용을 분석하여 클릭베이트 여부를 판단하는 전문가"
                    },
                    {
                        "role": "user",
                        "content": formatted_prompt
                    }
                ],
                "max_tokens": 500,
                "temperature": 0.1
            }
        }
        batch_requests.append(request)
    
    return batch_requests
```

**배치 생성 제약사항:**
- 일일 최대 배치 수 제한 (10개)
- 배치당 최대 요청 수 (50,000개)
- 입력 파일 크기 제한 (100MB)
- 중복 제거 및 검증

## 📊 상태 모니터링

### 배치 상태 테이블
```sql
CREATE TABLE batch_status (
  id UUID PRIMARY KEY,
  batch_id TEXT UNIQUE NOT NULL,
  status TEXT NOT NULL,
  created_at TIMESTAMP DEFAULT NOW(),
  updated_at TIMESTAMP DEFAULT NOW(),
  input_file_id TEXT,
  output_file_id TEXT,
  error_file_id TEXT,
  request_count INTEGER DEFAULT 0,
  completed_count INTEGER DEFAULT 0,
  failed_count INTEGER DEFAULT 0
);
```

### 모니터링 주기
- **진행 중**: 10분마다 상태 확인
- **완료됨**: 즉시 결과 처리
- **실패**: 에러 로그 기록 및 알림

## 🔄 결과 처리

### 출력 데이터 파싱
```python
def parse_batch_result(result_line):
    """배치 결과 파싱"""
    data = json.loads(result_line)
    custom_id = data['custom_id']
    
    if data['response']['status_code'] == 200:
        content = data['response']['body']['choices'][0]['message']['content']
        return parse_clickbait_score(content)
    else:
        return handle_error(data['response'])
```

### 점수 파싱 규칙
```python
import re

def parse_clickbait_score(content):
    """OpenAI 응답에서 클릭베이트 점수 추출"""
    # 새로운 출력 형식: score : [정수], reason : [설명]
    score_match = re.search(r'score\s*:\s*(\d+)', content, re.IGNORECASE)
    reason_match = re.search(r'reason\s*:\s*(.+)', content, re.IGNORECASE | re.DOTALL)
    
    if score_match:
        score = int(score_match.group(1))
        reason = reason_match.group(1).strip() if reason_match else ""
        
        # 점수 범위 검증 (0-100)
        if 0 <= score <= 100:
            return {
                'clickbait_score': score,
                'score_explanation': reason
            }
    
    # 파싱 실패 시 기본값 반환
    return {
        'clickbait_score': None,
        'score_explanation': f"응답 파싱 실패: {content[:100]}..."
    }
```

**파싱 에러 처리:**
- 점수 추출 실패 시 `None` 반환
- 점수 범위 벗어남 시 재검증 요청
- 응답 형식 불일치 시 로그 기록

## 🛠️ 에러 핸들링

### 배치 실패 처리
- **부분 실패**: 성공한 결과만 처리
- **전체 실패**: 재시도 로직 구현
- **타임아웃**: 24시간 후 자동 만료

### 복구 전략
- 실패한 요청 재배치
- 입력 데이터 검증 강화
- 토큰 사용량 모니터링

## 💰 비용 관리

### 토큰 사용량 추적
- 입력 토큰 수 계산
- 출력 토큰 수 모니터링
- 일일/월간 비용 한도 설정

### 최적화 전략
- 프롬프트 길이 최적화
- 배치 크기 조정
- 모델 선택 최적화 (gpt-4o-mini 사용)
